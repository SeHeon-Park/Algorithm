A = [int(x) for x in input().split()]

l = 0
r = len(A)-1
m = (l+r)//2

while l+1 != r:
	m = (l+r)//2
	if A[l] < A[m]:
		l = m
	else:
		r = m


if A[l] < A[r]:
	print(0)
else:
	print(len(A)-r)


# 결국 리스트에서 최대값을 찾는다면 몇번 로테이션 되었는지 확인 할 수 있다.(이진탐색 방식 활용)
# l과 m을 비교 하여 만약 l이 m보다 크다면 최대값은 l과 m사이에 있으므로 r을 m으로 update시켜 나머지 부분을 버린다.
# l이 m보다 작다면 최대값은 m과 r사이에 있으므로 l을 m으로 update시켜 나머지 부분을 버린다.
# 이 행위를 반복하다 보면 결국 l은 최대값위치, r은 로테이션 전 첫번째값 위치에 놓이게 된다.
# 여기서 로테이션이 한번도 되지 않은 경우는 l만 계속 m으로 update가 되므로 l과r이 리스트의 마지막 두개를 가르키고 정답과 다르므로 예외로 친다.
# 리스트길이에서 r을 빼면 로테이션 횟수를 구할 수 있다.

# 매 시행마다 (반-1)이 버려지고 결국 남은 데이터가 2개가 될때까지 반복한다.
# 따라서 (((n/2+1)*(1/2))+1)*1/2)+1 .... 형태이고 결국 데이터가 2개남을 때까지 k번 시행하는 경우 (1/2)^k*n + c = 2(c는 상수)형태가 된다.
# 양변에 2^k를 곱하면 n = 2^k(2 - c)가 되고 양변에 log를 취하면 k=logn-log(2-c)가 된다. 결국 O(logn)을 만족한다.


